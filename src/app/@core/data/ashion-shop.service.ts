//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_ASHIONSHOP_URL = new InjectionToken<string>('API_ASHIONSHOP_URL');

export interface IAshionShop {
    /**
     * @return Success
     */
    aboutSelectAll(): Observable<AboutModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    aboutDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    aboutInsert(body?: AboutModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    aboutSelectOne(id?: string | undefined): Observable<AboutModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    aboutUpdate(body?: AboutModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    aboutPagingAbout(body?: PageModel | undefined): Observable<AboutModelListPageModelViewApiResponse>;
    /**
     * @param type (optional) 
     * @return Success
     */
    categorySelectAll(type?: string | undefined): Observable<CategoryModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    categoryDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoryInsert(body?: CategoryModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @param type (optional) 
     * @return Success
     */
    categorySelectOne(id?: string | undefined, type?: string | undefined): Observable<CategoryModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoryUpdate(body?: CategoryModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPagingCategory(body?: PageModel | undefined): Observable<CategoryModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    commentSelectAll(): Observable<CommentModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    commentDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentInsert(body?: CommentModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    commentSelectOne(id?: string | undefined): Observable<CommentModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentUpdate(body?: CommentModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentPagingComment(body?: PageModel | undefined): Observable<CommentModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    commentErrorSelectAll(): Observable<CommentErrorModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    commentErrorDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorInsert(body?: CommentErrorModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    commentErrorSelectOne(id?: string | undefined): Observable<CommentErrorModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorUpdate(body?: CommentErrorModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorPagingCommentError(body?: PageModel | undefined): Observable<CommentErrorModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    feedBackSelectAll(): Observable<FeedBackModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    feedBackDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackInsert(body?: FeedBackModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    feedBackSelectOne(id?: string | undefined): Observable<FeedBackModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackUpdate(body?: FeedBackModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackPagingData(body?: PageModel | undefined): Observable<FeedBackModelListPageModelViewApiResponse>;
    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file?: FileParameter | undefined): Observable<FileModelApiResponse>;
    /**
     * @param file (optional) 
     * @return Success
     */
    uploadListFile(file?: FileParameter[] | undefined): Observable<FileModelListApiResponse>;
    /**
     * @param file (optional) 
     * @return Success
     */
    downloadFile(file?: string | undefined): Observable<StringApiResponse>;
    /**
     * @return Success
     */
    filesSelectAllInFolder(): Observable<StringListApiResponse>;
    /**
     * @param fileId (optional) 
     * @return Success
     */
    deleteFile(fileId?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    pagingFileAttachment(body?: PageModel | undefined): Observable<FileModelListPageModelViewApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertFile(body?: FileModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateFile(body?: FileModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    selectOneFile(id?: string | undefined): Observable<FileModelApiResponse>;
    /**
     * @return Success
     */
    selectAllFile(): Observable<FileModelListApiResponse>;
    /**
     * @param fileUrl (optional) 
     * @return Success
     */
    downloadFileData(fileUrl?: string | undefined): Observable<void>;
    /**
     * @return Success
     */
    footerSelectAll(): Observable<FooterModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    footerDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    footerInsert(body?: FooterModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    footerSelectOne(id?: string | undefined): Observable<FooterModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    footerUpdate(body?: FooterModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    footerPagingData(body?: PageModel | undefined): Observable<FooterModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    groupSateSelectAll(): Observable<GroupSateModelListApiResponse>;
    /**
     * @param ma (optional) 
     * @return Success
     */
    getListState(ma?: string | undefined): Observable<GroupSateModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    groupSateDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    groupSateInsert(body?: GroupSateModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    groupSateSelectOne(id?: string | undefined): Observable<GroupSateModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    groupSateUpdate(body?: GroupSateModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    groupSatePagingData(body?: PageModel | undefined): Observable<GroupSateModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    headerSelectAll(): Observable<HeaderModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    headerDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    headerInsert(body?: HeaderModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    headerSelectOne(id?: string | undefined): Observable<HeaderModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    headerUpdate(body?: HeaderModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    headerPagingData(body?: PageModel | undefined): Observable<HeaderModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    khoSpSelectAll(): Observable<KhoSpModelListApiResponse>;
    /**
     * @param type (optional) 
     * @return Success
     */
    getCodeProduct(type?: number | undefined): Observable<StringApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    khoSpDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpInsert(body?: KhoSpModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    khoSpSelectOne(id?: string | undefined): Observable<KhoSpModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpUpdate(body?: KhoSpModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpPagingData(body?: PageModel | undefined): Observable<KhoSpModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    productSelectAll(): Observable<ProductModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    productDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productInsert(body?: ProductModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    productSelectOne(id?: string | undefined): Observable<ProductModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productUpdate(body?: ProductModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    productPagingData(body?: PageModel | undefined): Observable<ProductModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    shippingCardSelectAll(): Observable<ShippingCardModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    shippingCardDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardInsert(body?: ShippingCardModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    shippingCardSelectOne(id?: string | undefined): Observable<ShippingCardModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardUpdate(body?: ShippingCardModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardPagingData(body?: PageModel | undefined): Observable<ShippingCardModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    shopUserSelectAll(): Observable<ShopUserModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    shopUserDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserInsert(body?: ShopUserModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    shopUserSelectOne(id?: string | undefined): Observable<ShopUserModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserUpdate(body?: ShopUserModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserPagingData(body?: PageModel | undefined): Observable<ShopUserModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    sliderSelectAll(): Observable<SliderModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sliderDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sliderInsert(body?: SliderModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sliderSelectOne(id?: string | undefined): Observable<SliderModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sliderUpdate(body?: SliderModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sliderPagingData(body?: PageModel | undefined): Observable<SliderModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    sysGroupSelectAll(): Observable<SysGroupModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysGroupDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupInsert(body?: SysGroupModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysGroupSelectOne(id?: string | undefined): Observable<SysGroupModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupUpdate(body?: SysGroupModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupPagingData(body?: PageModel | undefined): Observable<SysGroupModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    sysGroupMenuSelectAll(): Observable<SysGroupMenuModelListApiResponse>;
    /**
     * @param groupId (optional) 
     * @param menuId (optional) 
     * @return Success
     */
    sysGroupMenuDelete(groupId?: string | undefined, menuId?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuInsert(body?: SysGroupMenuModel | undefined): Observable<ApiResponse>;
    /**
     * @param groupId (optional) 
     * @param menuId (optional) 
     * @return Success
     */
    sysGroupMenuSelectOne(groupId?: string | undefined, menuId?: string | undefined): Observable<SysGroupMenuModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuUpdate(body?: SysGroupMenuModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuPagingData(body?: PageModel | undefined): Observable<SysGroupMenuModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    sysMenuSelectAll(): Observable<SysMenuModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysMenuDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuInsert(body?: SysMenuModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysMenuSelectOne(id?: string | undefined): Observable<SysMenuModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuUpdate(body?: SysMenuModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuPagingData(body?: PageModel | undefined): Observable<SysMenuModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    getListProvince(): Observable<List_ProvinceApiResponse>;
    /**
     * @param type (optional) 
     * @return Success
     */
    getListDistrict(type?: string | undefined): Observable<List_DistrictApiResponse>;
    /**
     * @param type (optional) 
     * @return Success
     */
    getListWard(type?: string | undefined): Observable<List_WardApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserLogin(body?: LoginUser | undefined): Observable<SysUserModelApiResponse>;
    /**
     * @return Success
     */
    sysUserSelectAll(): Observable<SysUserModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysUserSelectOne(id?: string | undefined): Observable<SysUserModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserInsert(body?: SysUserModel | undefined): Observable<ApiResponse>;
    /**
     * @param userid (optional) 
     * @param status (optional) 
     * @return Success
     */
    sysUserUpdateStatus(userid?: string | undefined, status?: number | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserUpdate(body?: SysUserModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    sysUserDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserPagingUser(body?: PageModel | undefined): Observable<SysUserModelListPageModelViewApiResponse>;
    /**
     * @return Success
     */
    voucherSelectAll(): Observable<VoucherModelListApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    voucherDelete(id?: string | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    voucherInsert(body?: VoucherModel | undefined): Observable<ApiResponse>;
    /**
     * @param id (optional) 
     * @return Success
     */
    voucherSelectOne(id?: string | undefined): Observable<VoucherModelApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    voucherUpdate(body?: VoucherModel | undefined): Observable<ApiResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    voucherPagingData(body?: PageModel | undefined): Observable<VoucherModelListPageModelViewApiResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AshionShop implements IAshionShop {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_ASHIONSHOP_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    aboutSelectAll(): Observable<AboutModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AboutModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AboutModelListApiResponse>;
        }));
    }

    protected processAboutSelectAll(response: HttpResponseBase): Observable<AboutModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AboutModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AboutModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aboutDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAboutDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aboutInsert(body?: AboutModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAboutInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aboutSelectOne(id?: string | undefined): Observable<AboutModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AboutModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AboutModelApiResponse>;
        }));
    }

    protected processAboutSelectOne(response: HttpResponseBase): Observable<AboutModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AboutModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AboutModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aboutUpdate(body?: AboutModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAboutUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aboutPagingAbout(body?: PageModel | undefined): Observable<AboutModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/About/AboutPagingAbout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAboutPagingAbout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAboutPagingAbout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AboutModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AboutModelListPageModelViewApiResponse>;
        }));
    }

    protected processAboutPagingAbout(response: HttpResponseBase): Observable<AboutModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AboutModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AboutModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    categorySelectAll(type?: string | undefined): Observable<CategoryModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategorySelectAll?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategorySelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategorySelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryModelListApiResponse>;
        }));
    }

    protected processCategorySelectAll(response: HttpResponseBase): Observable<CategoryModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CategoryModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    categoryDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategoryDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCategoryDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryInsert(body?: CategoryModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategoryInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCategoryInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param type (optional) 
     * @return Success
     */
    categorySelectOne(id?: string | undefined, type?: string | undefined): Observable<CategoryModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategorySelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategorySelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategorySelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryModelApiResponse>;
        }));
    }

    protected processCategorySelectOne(response: HttpResponseBase): Observable<CategoryModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CategoryModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryUpdate(body?: CategoryModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategoryUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCategoryUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPagingCategory(body?: PageModel | undefined): Observable<CategoryModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Category/CategoryPagingCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryPagingCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryPagingCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryModelListPageModelViewApiResponse>;
        }));
    }

    protected processCategoryPagingCategory(response: HttpResponseBase): Observable<CategoryModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CategoryModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    commentSelectAll(): Observable<CommentModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentModelListApiResponse>;
        }));
    }

    protected processCommentSelectAll(response: HttpResponseBase): Observable<CommentModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    commentDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentInsert(body?: CommentModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    commentSelectOne(id?: string | undefined): Observable<CommentModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentModelApiResponse>;
        }));
    }

    protected processCommentSelectOne(response: HttpResponseBase): Observable<CommentModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentUpdate(body?: CommentModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentPagingComment(body?: PageModel | undefined): Observable<CommentModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Comment/CommentPagingComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentPagingComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentPagingComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentModelListPageModelViewApiResponse>;
        }));
    }

    protected processCommentPagingComment(response: HttpResponseBase): Observable<CommentModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    commentErrorSelectAll(): Observable<CommentErrorModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentErrorModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentErrorModelListApiResponse>;
        }));
    }

    protected processCommentErrorSelectAll(response: HttpResponseBase): Observable<CommentErrorModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentErrorModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentErrorModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    commentErrorDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentErrorDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorInsert(body?: CommentErrorModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentErrorInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    commentErrorSelectOne(id?: string | undefined): Observable<CommentErrorModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentErrorModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentErrorModelApiResponse>;
        }));
    }

    protected processCommentErrorSelectOne(response: HttpResponseBase): Observable<CommentErrorModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentErrorModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentErrorModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorUpdate(body?: CommentErrorModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCommentErrorUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentErrorPagingCommentError(body?: PageModel | undefined): Observable<CommentErrorModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/CommentError/CommentErrorPagingCommentError";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentErrorPagingCommentError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentErrorPagingCommentError(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentErrorModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentErrorModelListPageModelViewApiResponse>;
        }));
    }

    protected processCommentErrorPagingCommentError(response: HttpResponseBase): Observable<CommentErrorModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CommentErrorModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentErrorModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    feedBackSelectAll(): Observable<FeedBackModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBackModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBackModelListApiResponse>;
        }));
    }

    protected processFeedBackSelectAll(response: HttpResponseBase): Observable<FeedBackModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FeedBackModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBackModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    feedBackDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFeedBackDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackInsert(body?: FeedBackModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFeedBackInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    feedBackSelectOne(id?: string | undefined): Observable<FeedBackModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBackModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBackModelApiResponse>;
        }));
    }

    protected processFeedBackSelectOne(response: HttpResponseBase): Observable<FeedBackModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FeedBackModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBackModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackUpdate(body?: FeedBackModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFeedBackUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    feedBackPagingData(body?: PageModel | undefined): Observable<FeedBackModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/FeedBack/FeedBackPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedBackModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedBackModelListPageModelViewApiResponse>;
        }));
    }

    protected processFeedBackPagingData(response: HttpResponseBase): Observable<FeedBackModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FeedBackModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeedBackModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file?: FileParameter | undefined): Observable<FileModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileModelApiResponse>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<FileModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FileModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileModelApiResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadListFile(file?: FileParameter[] | undefined): Observable<FileModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/UploadListFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadListFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadListFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileModelListApiResponse>;
        }));
    }

    protected processUploadListFile(response: HttpResponseBase): Observable<FileModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FileModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileModelListApiResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    downloadFile(file?: string | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/downloadFile?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    filesSelectAllInFolder(): Observable<StringListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/filesSelectAllInFolder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilesSelectAllInFolder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilesSelectAllInFolder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringListApiResponse>;
        }));
    }

    protected processFilesSelectAllInFolder(response: HttpResponseBase): Observable<StringListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = StringListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringListApiResponse>(null as any);
    }

    /**
     * @param fileId (optional) 
     * @return Success
     */
    deleteFile(fileId?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/DeleteFile?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pagingFileAttachment(body?: PageModel | undefined): Observable<FileModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/PagingFileAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingFileAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingFileAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileModelListPageModelViewApiResponse>;
        }));
    }

    protected processPagingFileAttachment(response: HttpResponseBase): Observable<FileModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FileModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertFile(body?: FileModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/InsertFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processInsertFile(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFile(body?: FileModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/UpdateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    selectOneFile(id?: string | undefined): Observable<FileModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/SelectOneFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectOneFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectOneFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileModelApiResponse>;
        }));
    }

    protected processSelectOneFile(response: HttpResponseBase): Observable<FileModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FileModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileModelApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    selectAllFile(): Observable<FileModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/SelectAllFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectAllFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectAllFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileModelListApiResponse>;
        }));
    }

    protected processSelectAllFile(response: HttpResponseBase): Observable<FileModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FileModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileModelListApiResponse>(null as any);
    }

    /**
     * @param fileUrl (optional) 
     * @return Success
     */
    downloadFileData(fileUrl?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/File/downloadFileData?";
        if (fileUrl === null)
            throw new Error("The parameter 'fileUrl' cannot be null.");
        else if (fileUrl !== undefined)
            url_ += "fileUrl=" + encodeURIComponent("" + fileUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadFileData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    footerSelectAll(): Observable<FooterModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterModelListApiResponse>;
        }));
    }

    protected processFooterSelectAll(response: HttpResponseBase): Observable<FooterModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FooterModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FooterModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    footerDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFooterDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    footerInsert(body?: FooterModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFooterInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    footerSelectOne(id?: string | undefined): Observable<FooterModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterModelApiResponse>;
        }));
    }

    protected processFooterSelectOne(response: HttpResponseBase): Observable<FooterModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FooterModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FooterModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    footerUpdate(body?: FooterModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processFooterUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    footerPagingData(body?: PageModel | undefined): Observable<FooterModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Footer/FooterPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFooterPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFooterPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FooterModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FooterModelListPageModelViewApiResponse>;
        }));
    }

    protected processFooterPagingData(response: HttpResponseBase): Observable<FooterModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FooterModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FooterModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    groupSateSelectAll(): Observable<GroupSateModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSateSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSateSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSateSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupSateModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupSateModelListApiResponse>;
        }));
    }

    protected processGroupSateSelectAll(response: HttpResponseBase): Observable<GroupSateModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GroupSateModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupSateModelListApiResponse>(null as any);
    }

    /**
     * @param ma (optional) 
     * @return Success
     */
    getListState(ma?: string | undefined): Observable<GroupSateModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/getListState?";
        if (ma === null)
            throw new Error("The parameter 'ma' cannot be null.");
        else if (ma !== undefined)
            url_ += "ma=" + encodeURIComponent("" + ma) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupSateModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupSateModelListApiResponse>;
        }));
    }

    protected processGetListState(response: HttpResponseBase): Observable<GroupSateModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GroupSateModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupSateModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    groupSateDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSateDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSateDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSateDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processGroupSateDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    groupSateInsert(body?: GroupSateModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSateInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSateInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSateInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processGroupSateInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    groupSateSelectOne(id?: string | undefined): Observable<GroupSateModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSateSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSateSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSateSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupSateModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupSateModelApiResponse>;
        }));
    }

    protected processGroupSateSelectOne(response: HttpResponseBase): Observable<GroupSateModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GroupSateModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupSateModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    groupSateUpdate(body?: GroupSateModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSateUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSateUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSateUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processGroupSateUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    groupSatePagingData(body?: PageModel | undefined): Observable<GroupSateModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/GroupState/GroupSatePagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupSatePagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupSatePagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupSateModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupSateModelListPageModelViewApiResponse>;
        }));
    }

    protected processGroupSatePagingData(response: HttpResponseBase): Observable<GroupSateModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GroupSateModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupSateModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    headerSelectAll(): Observable<HeaderModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeaderModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeaderModelListApiResponse>;
        }));
    }

    protected processHeaderSelectAll(response: HttpResponseBase): Observable<HeaderModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = HeaderModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeaderModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    headerDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processHeaderDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    headerInsert(body?: HeaderModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processHeaderInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    headerSelectOne(id?: string | undefined): Observable<HeaderModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeaderModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeaderModelApiResponse>;
        }));
    }

    protected processHeaderSelectOne(response: HttpResponseBase): Observable<HeaderModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = HeaderModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeaderModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    headerUpdate(body?: HeaderModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processHeaderUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    headerPagingData(body?: PageModel | undefined): Observable<HeaderModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Header/HeaderPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeaderPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeaderPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeaderModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeaderModelListPageModelViewApiResponse>;
        }));
    }

    protected processHeaderPagingData(response: HttpResponseBase): Observable<HeaderModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = HeaderModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeaderModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    khoSpSelectAll(): Observable<KhoSpModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhoSpModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhoSpModelListApiResponse>;
        }));
    }

    protected processKhoSpSelectAll(response: HttpResponseBase): Observable<KhoSpModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = KhoSpModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhoSpModelListApiResponse>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getCodeProduct(type?: number | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/getCodeProduct?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCodeProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCodeProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processGetCodeProduct(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    khoSpDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processKhoSpDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpInsert(body?: KhoSpModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processKhoSpInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    khoSpSelectOne(id?: string | undefined): Observable<KhoSpModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhoSpModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhoSpModelApiResponse>;
        }));
    }

    protected processKhoSpSelectOne(response: HttpResponseBase): Observable<KhoSpModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = KhoSpModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhoSpModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpUpdate(body?: KhoSpModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processKhoSpUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    khoSpPagingData(body?: PageModel | undefined): Observable<KhoSpModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/KhoSp/KhoSpPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKhoSpPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKhoSpPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhoSpModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhoSpModelListPageModelViewApiResponse>;
        }));
    }

    protected processKhoSpPagingData(response: HttpResponseBase): Observable<KhoSpModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = KhoSpModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KhoSpModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    productSelectAll(): Observable<ProductModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModelListApiResponse>;
        }));
    }

    protected processProductSelectAll(response: HttpResponseBase): Observable<ProductModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProductModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    productDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processProductDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productInsert(body?: ProductModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processProductInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    productSelectOne(id?: string | undefined): Observable<ProductModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModelApiResponse>;
        }));
    }

    protected processProductSelectOne(response: HttpResponseBase): Observable<ProductModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProductModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productUpdate(body?: ProductModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processProductUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productPagingData(body?: PageModel | undefined): Observable<ProductModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Product/ProductPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductModelListPageModelViewApiResponse>;
        }));
    }

    protected processProductPagingData(response: HttpResponseBase): Observable<ProductModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ProductModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    shippingCardSelectAll(): Observable<ShippingCardModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShippingCardModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShippingCardModelListApiResponse>;
        }));
    }

    protected processShippingCardSelectAll(response: HttpResponseBase): Observable<ShippingCardModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShippingCardModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShippingCardModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    shippingCardDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShippingCardDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardInsert(body?: ShippingCardModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShippingCardInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    shippingCardSelectOne(id?: string | undefined): Observable<ShippingCardModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShippingCardModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShippingCardModelApiResponse>;
        }));
    }

    protected processShippingCardSelectOne(response: HttpResponseBase): Observable<ShippingCardModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShippingCardModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShippingCardModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardUpdate(body?: ShippingCardModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShippingCardUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shippingCardPagingData(body?: PageModel | undefined): Observable<ShippingCardModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShippingCard/ShippingCardPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShippingCardPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShippingCardPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShippingCardModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShippingCardModelListPageModelViewApiResponse>;
        }));
    }

    protected processShippingCardPagingData(response: HttpResponseBase): Observable<ShippingCardModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShippingCardModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShippingCardModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    shopUserSelectAll(): Observable<ShopUserModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShopUserModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShopUserModelListApiResponse>;
        }));
    }

    protected processShopUserSelectAll(response: HttpResponseBase): Observable<ShopUserModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShopUserModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopUserModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    shopUserDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShopUserDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserInsert(body?: ShopUserModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShopUserInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    shopUserSelectOne(id?: string | undefined): Observable<ShopUserModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShopUserModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShopUserModelApiResponse>;
        }));
    }

    protected processShopUserSelectOne(response: HttpResponseBase): Observable<ShopUserModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShopUserModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopUserModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserUpdate(body?: ShopUserModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processShopUserUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shopUserPagingData(body?: PageModel | undefined): Observable<ShopUserModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/ShopUser/ShopUserPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShopUserPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShopUserPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShopUserModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShopUserModelListPageModelViewApiResponse>;
        }));
    }

    protected processShopUserPagingData(response: HttpResponseBase): Observable<ShopUserModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ShopUserModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopUserModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    sliderSelectAll(): Observable<SliderModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderModelListApiResponse>;
        }));
    }

    protected processSliderSelectAll(response: HttpResponseBase): Observable<SliderModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SliderModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SliderModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sliderDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSliderDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sliderInsert(body?: SliderModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSliderInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sliderSelectOne(id?: string | undefined): Observable<SliderModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderModelApiResponse>;
        }));
    }

    protected processSliderSelectOne(response: HttpResponseBase): Observable<SliderModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SliderModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SliderModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sliderUpdate(body?: SliderModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSliderUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sliderPagingData(body?: PageModel | undefined): Observable<SliderModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Slider/SliderPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSliderPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSliderPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SliderModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SliderModelListPageModelViewApiResponse>;
        }));
    }

    protected processSliderPagingData(response: HttpResponseBase): Observable<SliderModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SliderModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SliderModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    sysGroupSelectAll(): Observable<SysGroupModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupModelListApiResponse>;
        }));
    }

    protected processSysGroupSelectAll(response: HttpResponseBase): Observable<SysGroupModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysGroupDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupInsert(body?: SysGroupModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysGroupSelectOne(id?: string | undefined): Observable<SysGroupModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupModelApiResponse>;
        }));
    }

    protected processSysGroupSelectOne(response: HttpResponseBase): Observable<SysGroupModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupUpdate(body?: SysGroupModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupPagingData(body?: PageModel | undefined): Observable<SysGroupModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroup/SysGroupPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupModelListPageModelViewApiResponse>;
        }));
    }

    protected processSysGroupPagingData(response: HttpResponseBase): Observable<SysGroupModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    sysGroupMenuSelectAll(): Observable<SysGroupMenuModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupMenuModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupMenuModelListApiResponse>;
        }));
    }

    protected processSysGroupMenuSelectAll(response: HttpResponseBase): Observable<SysGroupMenuModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupMenuModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupMenuModelListApiResponse>(null as any);
    }

    /**
     * @param groupId (optional) 
     * @param menuId (optional) 
     * @return Success
     */
    sysGroupMenuDelete(groupId?: string | undefined, menuId?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuDelete?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupMenuDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuInsert(body?: SysGroupMenuModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupMenuInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param groupId (optional) 
     * @param menuId (optional) 
     * @return Success
     */
    sysGroupMenuSelectOne(groupId?: string | undefined, menuId?: string | undefined): Observable<SysGroupMenuModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuSelectOne?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupMenuModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupMenuModelApiResponse>;
        }));
    }

    protected processSysGroupMenuSelectOne(response: HttpResponseBase): Observable<SysGroupMenuModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupMenuModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupMenuModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuUpdate(body?: SysGroupMenuModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysGroupMenuUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysGroupMenuPagingData(body?: PageModel | undefined): Observable<SysGroupMenuModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysGroupMenu/SysGroupMenuPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysGroupMenuPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysGroupMenuPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysGroupMenuModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysGroupMenuModelListPageModelViewApiResponse>;
        }));
    }

    protected processSysGroupMenuPagingData(response: HttpResponseBase): Observable<SysGroupMenuModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysGroupMenuModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysGroupMenuModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    sysMenuSelectAll(): Observable<SysMenuModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenuModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenuModelListApiResponse>;
        }));
    }

    protected processSysMenuSelectAll(response: HttpResponseBase): Observable<SysMenuModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysMenuModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysMenuModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysMenuDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysMenuDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuInsert(body?: SysMenuModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysMenuInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysMenuSelectOne(id?: string | undefined): Observable<SysMenuModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenuModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenuModelApiResponse>;
        }));
    }

    protected processSysMenuSelectOne(response: HttpResponseBase): Observable<SysMenuModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysMenuModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysMenuModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuUpdate(body?: SysMenuModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysMenuUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysMenuPagingData(body?: PageModel | undefined): Observable<SysMenuModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysMenu/SysMenuPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysMenuPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenuModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenuModelListPageModelViewApiResponse>;
        }));
    }

    protected processSysMenuPagingData(response: HttpResponseBase): Observable<SysMenuModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysMenuModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysMenuModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    getListProvince(): Observable<List_ProvinceApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/GetListProvince";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListProvince(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<List_ProvinceApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<List_ProvinceApiResponse>;
        }));
    }

    protected processGetListProvince(response: HttpResponseBase): Observable<List_ProvinceApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = List_ProvinceApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List_ProvinceApiResponse>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getListDistrict(type?: string | undefined): Observable<List_DistrictApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/GetListDistrict?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListDistrict(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListDistrict(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<List_DistrictApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<List_DistrictApiResponse>;
        }));
    }

    protected processGetListDistrict(response: HttpResponseBase): Observable<List_DistrictApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = List_DistrictApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List_DistrictApiResponse>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getListWard(type?: string | undefined): Observable<List_WardApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/GetListWard?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListWard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<List_WardApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<List_WardApiResponse>;
        }));
    }

    protected processGetListWard(response: HttpResponseBase): Observable<List_WardApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = List_WardApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List_WardApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserLogin(body?: LoginUser | undefined): Observable<SysUserModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysUserModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysUserModelApiResponse>;
        }));
    }

    protected processSysUserLogin(response: HttpResponseBase): Observable<SysUserModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysUserModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysUserModelApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    sysUserSelectAll(): Observable<SysUserModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysUserModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysUserModelListApiResponse>;
        }));
    }

    protected processSysUserSelectAll(response: HttpResponseBase): Observable<SysUserModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysUserModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysUserModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysUserSelectOne(id?: string | undefined): Observable<SysUserModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysUserModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysUserModelApiResponse>;
        }));
    }

    protected processSysUserSelectOne(response: HttpResponseBase): Observable<SysUserModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysUserModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysUserModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserInsert(body?: SysUserModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysUserInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param userid (optional) 
     * @param status (optional) 
     * @return Success
     */
    sysUserUpdateStatus(userid?: string | undefined, status?: number | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserUpdateStatus?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysUserUpdateStatus(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserUpdate(body?: SysUserModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysUserUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sysUserDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSysUserDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sysUserPagingUser(body?: PageModel | undefined): Observable<SysUserModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/SysUser/SysUserPagingUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSysUserPagingUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysUserPagingUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysUserModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysUserModelListPageModelViewApiResponse>;
        }));
    }

    protected processSysUserPagingUser(response: HttpResponseBase): Observable<SysUserModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SysUserModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SysUserModelListPageModelViewApiResponse>(null as any);
    }

    /**
     * @return Success
     */
    voucherSelectAll(): Observable<VoucherModelListApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherSelectAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherSelectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherSelectAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoucherModelListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoucherModelListApiResponse>;
        }));
    }

    protected processVoucherSelectAll(response: HttpResponseBase): Observable<VoucherModelListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VoucherModelListApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoucherModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    voucherDelete(id?: string | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processVoucherDelete(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    voucherInsert(body?: VoucherModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processVoucherInsert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    voucherSelectOne(id?: string | undefined): Observable<VoucherModelApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherSelectOne?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherSelectOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherSelectOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoucherModelApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoucherModelApiResponse>;
        }));
    }

    protected processVoucherSelectOne(response: HttpResponseBase): Observable<VoucherModelApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VoucherModelApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoucherModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    voucherUpdate(body?: VoucherModel | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processVoucherUpdate(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    voucherPagingData(body?: PageModel | undefined): Observable<VoucherModelListPageModelViewApiResponse> {
        let url_ = this.baseUrl + "/AshionShop/api/v1/Voucher/VoucherPagingData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "text/plain; x-api-version=1.0"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherPagingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherPagingData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoucherModelListPageModelViewApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoucherModelListPageModelViewApiResponse>;
        }));
    }

    protected processVoucherPagingData(response: HttpResponseBase): Observable<VoucherModelListPageModelViewApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = VoucherModelListPageModelViewApiResponse.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoucherModelListPageModelViewApiResponse>(null as any);
    }
}

export class AboutModel implements IAboutModel {
    aboutId?: string | undefined;
    tieuDe?: string | undefined;
    mota?: string | undefined;
    noiDung?: string | undefined;
    categoryId?: string | undefined;
    tendanhmuc?: string | undefined;
    nguoiTao?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;

    constructor(data?: IAboutModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.aboutId = _data["aboutId"];
            this.tieuDe = _data["tieuDe"];
            this.mota = _data["mota"];
            this.noiDung = _data["noiDung"];
            this.categoryId = _data["categoryId"];
            this.tendanhmuc = _data["tendanhmuc"];
            this.nguoiTao = _data["nguoiTao"];
            this.trangThai = _data["trangThai"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AboutModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AboutModel>(data, _mappings, AboutModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aboutId"] = this.aboutId;
        data["tieuDe"] = this.tieuDe;
        data["mota"] = this.mota;
        data["noiDung"] = this.noiDung;
        data["categoryId"] = this.categoryId;
        data["tendanhmuc"] = this.tendanhmuc;
        data["nguoiTao"] = this.nguoiTao;
        data["trangThai"] = this.trangThai;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAboutModel {
    aboutId?: string | undefined;
    tieuDe?: string | undefined;
    mota?: string | undefined;
    noiDung?: string | undefined;
    categoryId?: string | undefined;
    tendanhmuc?: string | undefined;
    nguoiTao?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
}

export class AboutModelApiResponse implements IAboutModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: AboutModel;

    constructor(data?: IAboutModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new AboutModel(data.data) : <AboutModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? AboutModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AboutModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AboutModelApiResponse>(data, _mappings, AboutModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAboutModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IAboutModel;
}

export class AboutModelListApiResponse implements IAboutModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: AboutModel[] | undefined;

    constructor(data?: IAboutModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new AboutModel(item) : <AboutModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AboutModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): AboutModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AboutModelListApiResponse>(data, _mappings, AboutModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAboutModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IAboutModel[] | undefined;
}

export class AboutModelListPageModelView implements IAboutModelListPageModelView {
    data?: AboutModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IAboutModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new AboutModel(item) : <AboutModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AboutModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): AboutModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AboutModelListPageModelView>(data, _mappings, AboutModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IAboutModelListPageModelView {
    data?: IAboutModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class AboutModelListPageModelViewApiResponse implements IAboutModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: AboutModelListPageModelView;

    constructor(data?: IAboutModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new AboutModelListPageModelView(data.data) : <AboutModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? AboutModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AboutModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AboutModelListPageModelViewApiResponse>(data, _mappings, AboutModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAboutModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IAboutModelListPageModelView;
}

export class ApiResponse implements IApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: boolean;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any, _mappings?: any): ApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ApiResponse>(data, _mappings, ApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: boolean;
}

export class CategoryModel implements ICategoryModel {
    id?: string | undefined;
    tenDanhMuc?: string | undefined;
    typeDanhMuc?: string | undefined;
    maDanhMuc?: string | undefined;
    maCha?: string | undefined;
    nguoiTao?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenDanhMuc = _data["tenDanhMuc"];
            this.typeDanhMuc = _data["typeDanhMuc"];
            this.maDanhMuc = _data["maDanhMuc"];
            this.maCha = _data["maCha"];
            this.nguoiTao = _data["nguoiTao"];
            this.trangThai = _data["trangThai"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryModel>(data, _mappings, CategoryModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenDanhMuc"] = this.tenDanhMuc;
        data["typeDanhMuc"] = this.typeDanhMuc;
        data["maDanhMuc"] = this.maDanhMuc;
        data["maCha"] = this.maCha;
        data["nguoiTao"] = this.nguoiTao;
        data["trangThai"] = this.trangThai;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryModel {
    id?: string | undefined;
    tenDanhMuc?: string | undefined;
    typeDanhMuc?: string | undefined;
    maDanhMuc?: string | undefined;
    maCha?: string | undefined;
    nguoiTao?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
}

export class CategoryModelApiResponse implements ICategoryModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CategoryModel;

    constructor(data?: ICategoryModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CategoryModel(data.data) : <CategoryModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CategoryModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryModelApiResponse>(data, _mappings, CategoryModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICategoryModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICategoryModel;
}

export class CategoryModelListApiResponse implements ICategoryModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CategoryModel[] | undefined;

    constructor(data?: ICategoryModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CategoryModel(item) : <CategoryModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryModelListApiResponse>(data, _mappings, CategoryModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICategoryModel[] | undefined;
}

export class CategoryModelListPageModelView implements ICategoryModelListPageModelView {
    data?: CategoryModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ICategoryModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CategoryModel(item) : <CategoryModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryModelListPageModelView>(data, _mappings, CategoryModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ICategoryModelListPageModelView {
    data?: ICategoryModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class CategoryModelListPageModelViewApiResponse implements ICategoryModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CategoryModelListPageModelView;

    constructor(data?: ICategoryModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CategoryModelListPageModelView(data.data) : <CategoryModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CategoryModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CategoryModelListPageModelViewApiResponse>(data, _mappings, CategoryModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICategoryModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICategoryModelListPageModelView;
}

export class CommentErrorModel implements ICommentErrorModel {
    id?: string | undefined;
    textError?: string | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;

    constructor(data?: ICommentErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.textError = _data["textError"];
            this.trangThai = _data["trangThai"];
            this.nguoiTao = _data["nguoiTao"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CommentErrorModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentErrorModel>(data, _mappings, CommentErrorModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["textError"] = this.textError;
        data["trangThai"] = this.trangThai;
        data["nguoiTao"] = this.nguoiTao;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICommentErrorModel {
    id?: string | undefined;
    textError?: string | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
}

export class CommentErrorModelApiResponse implements ICommentErrorModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentErrorModel;

    constructor(data?: ICommentErrorModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CommentErrorModel(data.data) : <CommentErrorModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CommentErrorModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CommentErrorModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentErrorModelApiResponse>(data, _mappings, CommentErrorModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentErrorModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentErrorModel;
}

export class CommentErrorModelListApiResponse implements ICommentErrorModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentErrorModel[] | undefined;

    constructor(data?: ICommentErrorModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CommentErrorModel(item) : <CommentErrorModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CommentErrorModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CommentErrorModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentErrorModelListApiResponse>(data, _mappings, CommentErrorModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommentErrorModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentErrorModel[] | undefined;
}

export class CommentErrorModelListPageModelView implements ICommentErrorModelListPageModelView {
    data?: CommentErrorModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ICommentErrorModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CommentErrorModel(item) : <CommentErrorModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CommentErrorModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): CommentErrorModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentErrorModelListPageModelView>(data, _mappings, CommentErrorModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ICommentErrorModelListPageModelView {
    data?: ICommentErrorModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class CommentErrorModelListPageModelViewApiResponse implements ICommentErrorModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentErrorModelListPageModelView;

    constructor(data?: ICommentErrorModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CommentErrorModelListPageModelView(data.data) : <CommentErrorModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CommentErrorModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CommentErrorModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentErrorModelListPageModelViewApiResponse>(data, _mappings, CommentErrorModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentErrorModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentErrorModelListPageModelView;
}

export class CommentModel implements ICommentModel {
    id?: string | undefined;
    fullName?: string | undefined;
    commentCode?: string | undefined;
    maCha?: string | undefined;
    khoId?: string | undefined;
    aboutId?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    noiDung?: string | undefined;

    constructor(data?: ICommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.commentCode = _data["commentCode"];
            this.maCha = _data["maCha"];
            this.khoId = _data["khoId"];
            this.aboutId = _data["aboutId"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any, _mappings?: any): CommentModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentModel>(data, _mappings, CommentModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["commentCode"] = this.commentCode;
        data["maCha"] = this.maCha;
        data["khoId"] = this.khoId;
        data["aboutId"] = this.aboutId;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["noiDung"] = this.noiDung;
        return data;
    }
}

export interface ICommentModel {
    id?: string | undefined;
    fullName?: string | undefined;
    commentCode?: string | undefined;
    maCha?: string | undefined;
    khoId?: string | undefined;
    aboutId?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    noiDung?: string | undefined;
}

export class CommentModelApiResponse implements ICommentModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentModel;

    constructor(data?: ICommentModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CommentModel(data.data) : <CommentModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CommentModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CommentModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentModelApiResponse>(data, _mappings, CommentModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentModel;
}

export class CommentModelListApiResponse implements ICommentModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentModel[] | undefined;

    constructor(data?: ICommentModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CommentModel(item) : <CommentModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CommentModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CommentModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentModelListApiResponse>(data, _mappings, CommentModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommentModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentModel[] | undefined;
}

export class CommentModelListPageModelView implements ICommentModelListPageModelView {
    data?: CommentModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ICommentModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new CommentModel(item) : <CommentModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CommentModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): CommentModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentModelListPageModelView>(data, _mappings, CommentModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ICommentModelListPageModelView {
    data?: ICommentModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class CommentModelListPageModelViewApiResponse implements ICommentModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: CommentModelListPageModelView;

    constructor(data?: ICommentModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new CommentModelListPageModelView(data.data) : <CommentModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? CommentModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CommentModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CommentModelListPageModelViewApiResponse>(data, _mappings, CommentModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ICommentModelListPageModelView;
}

export class FeedBackModel implements IFeedBackModel {
    id?: string | undefined;
    fullName?: string | undefined;
    noiDung?: string | undefined;
    tieuDe?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: number | undefined;
    rateStar?: number | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IFeedBackModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.noiDung = _data["noiDung"];
            this.tieuDe = _data["tieuDe"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.rateStar = _data["rateStar"];
            this.trangThai = _data["trangThai"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBackModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBackModel>(data, _mappings, FeedBackModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["noiDung"] = this.noiDung;
        data["tieuDe"] = this.tieuDe;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["rateStar"] = this.rateStar;
        data["trangThai"] = this.trangThai;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IFeedBackModel {
    id?: string | undefined;
    fullName?: string | undefined;
    noiDung?: string | undefined;
    tieuDe?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: number | undefined;
    rateStar?: number | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;
}

export class FeedBackModelApiResponse implements IFeedBackModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FeedBackModel;

    constructor(data?: IFeedBackModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FeedBackModel(data.data) : <FeedBackModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FeedBackModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBackModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBackModelApiResponse>(data, _mappings, FeedBackModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeedBackModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFeedBackModel;
}

export class FeedBackModelListApiResponse implements IFeedBackModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FeedBackModel[] | undefined;

    constructor(data?: IFeedBackModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FeedBackModel(item) : <FeedBackModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FeedBackModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBackModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBackModelListApiResponse>(data, _mappings, FeedBackModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeedBackModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFeedBackModel[] | undefined;
}

export class FeedBackModelListPageModelView implements IFeedBackModelListPageModelView {
    data?: FeedBackModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IFeedBackModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FeedBackModel(item) : <FeedBackModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FeedBackModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBackModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBackModelListPageModelView>(data, _mappings, FeedBackModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IFeedBackModelListPageModelView {
    data?: IFeedBackModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class FeedBackModelListPageModelViewApiResponse implements IFeedBackModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FeedBackModelListPageModelView;

    constructor(data?: IFeedBackModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FeedBackModelListPageModelView(data.data) : <FeedBackModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FeedBackModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FeedBackModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FeedBackModelListPageModelViewApiResponse>(data, _mappings, FeedBackModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeedBackModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFeedBackModelListPageModelView;
}

export class FileModel implements IFileModel {
    id?: string | undefined;
    fileNameFull?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    updateDate?: Date | undefined;
    type?: number | undefined;
    status?: number | undefined;

    constructor(data?: IFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileNameFull = _data["fileNameFull"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any, _mappings?: any): FileModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileModel>(data, _mappings, FileModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileNameFull"] = this.fileNameFull;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        return data;
    }
}

export interface IFileModel {
    id?: string | undefined;
    fileNameFull?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    updateDate?: Date | undefined;
    type?: number | undefined;
    status?: number | undefined;
}

export class FileModelApiResponse implements IFileModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FileModel;

    constructor(data?: IFileModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FileModel(data.data) : <FileModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FileModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FileModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileModelApiResponse>(data, _mappings, FileModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFileModel;
}

export class FileModelListApiResponse implements IFileModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FileModel[] | undefined;

    constructor(data?: IFileModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FileModel(item) : <FileModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FileModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FileModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileModelListApiResponse>(data, _mappings, FileModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFileModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFileModel[] | undefined;
}

export class FileModelListPageModelView implements IFileModelListPageModelView {
    data?: FileModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IFileModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FileModel(item) : <FileModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FileModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): FileModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileModelListPageModelView>(data, _mappings, FileModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IFileModelListPageModelView {
    data?: IFileModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class FileModelListPageModelViewApiResponse implements IFileModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FileModelListPageModelView;

    constructor(data?: IFileModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FileModelListPageModelView(data.data) : <FileModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FileModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FileModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileModelListPageModelViewApiResponse>(data, _mappings, FileModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFileModelListPageModelView;
}

export class FooterModel implements IFooterModel {
    id?: string | undefined;
    logoImage?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    contentFooter?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IFooterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.logoImage = _data["logoImage"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.contentFooter = _data["contentFooter"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): FooterModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FooterModel>(data, _mappings, FooterModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["logoImage"] = this.logoImage;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["contentFooter"] = this.contentFooter;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IFooterModel {
    id?: string | undefined;
    logoImage?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    contentFooter?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
}

export class FooterModelApiResponse implements IFooterModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FooterModel;

    constructor(data?: IFooterModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FooterModel(data.data) : <FooterModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FooterModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FooterModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FooterModelApiResponse>(data, _mappings, FooterModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFooterModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFooterModel;
}

export class FooterModelListApiResponse implements IFooterModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FooterModel[] | undefined;

    constructor(data?: IFooterModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FooterModel(item) : <FooterModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FooterModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FooterModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FooterModelListApiResponse>(data, _mappings, FooterModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFooterModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFooterModel[] | undefined;
}

export class FooterModelListPageModelView implements IFooterModelListPageModelView {
    data?: FooterModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IFooterModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new FooterModel(item) : <FooterModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FooterModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): FooterModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FooterModelListPageModelView>(data, _mappings, FooterModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IFooterModelListPageModelView {
    data?: IFooterModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class FooterModelListPageModelViewApiResponse implements IFooterModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: FooterModelListPageModelView;

    constructor(data?: IFooterModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new FooterModelListPageModelView(data.data) : <FooterModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? FooterModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): FooterModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FooterModelListPageModelViewApiResponse>(data, _mappings, FooterModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFooterModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IFooterModelListPageModelView;
}

export class GroupSateModel implements IGroupSateModel {
    id?: string | undefined;
    nameState?: string | undefined;
    typeState?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IGroupSateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameState = _data["nameState"];
            this.typeState = _data["typeState"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): GroupSateModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupSateModel>(data, _mappings, GroupSateModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameState"] = this.nameState;
        data["typeState"] = this.typeState;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IGroupSateModel {
    id?: string | undefined;
    nameState?: string | undefined;
    typeState?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
}

export class GroupSateModelApiResponse implements IGroupSateModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: GroupSateModel;

    constructor(data?: IGroupSateModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new GroupSateModel(data.data) : <GroupSateModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? GroupSateModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GroupSateModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupSateModelApiResponse>(data, _mappings, GroupSateModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupSateModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IGroupSateModel;
}

export class GroupSateModelListApiResponse implements IGroupSateModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: GroupSateModel[] | undefined;

    constructor(data?: IGroupSateModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new GroupSateModel(item) : <GroupSateModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GroupSateModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GroupSateModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupSateModelListApiResponse>(data, _mappings, GroupSateModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupSateModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IGroupSateModel[] | undefined;
}

export class GroupSateModelListPageModelView implements IGroupSateModelListPageModelView {
    data?: GroupSateModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IGroupSateModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new GroupSateModel(item) : <GroupSateModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GroupSateModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): GroupSateModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupSateModelListPageModelView>(data, _mappings, GroupSateModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IGroupSateModelListPageModelView {
    data?: IGroupSateModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class GroupSateModelListPageModelViewApiResponse implements IGroupSateModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: GroupSateModelListPageModelView;

    constructor(data?: IGroupSateModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new GroupSateModelListPageModelView(data.data) : <GroupSateModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? GroupSateModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GroupSateModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupSateModelListPageModelViewApiResponse>(data, _mappings, GroupSateModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupSateModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IGroupSateModelListPageModelView;
}

export class HeaderModel implements IHeaderModel {
    id?: string | undefined;
    imageLogo?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    backGround?: string | undefined;
    contentDesign?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IHeaderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imageLogo = _data["imageLogo"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.backGround = _data["backGround"];
            this.contentDesign = _data["contentDesign"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): HeaderModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HeaderModel>(data, _mappings, HeaderModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageLogo"] = this.imageLogo;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["backGround"] = this.backGround;
        data["contentDesign"] = this.contentDesign;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IHeaderModel {
    id?: string | undefined;
    imageLogo?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    backGround?: string | undefined;
    contentDesign?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
}

export class HeaderModelApiResponse implements IHeaderModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: HeaderModel;

    constructor(data?: IHeaderModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new HeaderModel(data.data) : <HeaderModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? HeaderModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): HeaderModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HeaderModelApiResponse>(data, _mappings, HeaderModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHeaderModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IHeaderModel;
}

export class HeaderModelListApiResponse implements IHeaderModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: HeaderModel[] | undefined;

    constructor(data?: IHeaderModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new HeaderModel(item) : <HeaderModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(HeaderModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): HeaderModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HeaderModelListApiResponse>(data, _mappings, HeaderModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHeaderModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IHeaderModel[] | undefined;
}

export class HeaderModelListPageModelView implements IHeaderModelListPageModelView {
    data?: HeaderModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IHeaderModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new HeaderModel(item) : <HeaderModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(HeaderModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): HeaderModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HeaderModelListPageModelView>(data, _mappings, HeaderModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IHeaderModelListPageModelView {
    data?: IHeaderModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class HeaderModelListPageModelViewApiResponse implements IHeaderModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: HeaderModelListPageModelView;

    constructor(data?: IHeaderModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new HeaderModelListPageModelView(data.data) : <HeaderModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? HeaderModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): HeaderModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<HeaderModelListPageModelViewApiResponse>(data, _mappings, HeaderModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHeaderModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IHeaderModelListPageModelView;
}

export class KhoSpModel implements IKhoSpModel {
    khoId?: string | undefined;
    tenSanPham?: string | undefined;
    maSp?: string | undefined;
    soLuong?: number | undefined;
    shopId?: string | undefined;
    productId?: string | undefined;
    canNang?: number | undefined;
    dai?: number | undefined;
    rong?: number | undefined;
    cao?: number | undefined;
    image?: string | undefined;
    listImage?: string | undefined;
    colorId?: string | undefined;
    sizeId?: string | undefined;
    giaSp?: number | undefined;
    giaCu?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    categoryId?: string | undefined;
    moTaSanPham?: string | undefined;
    title?: string | undefined;
    chiTietSanPham?: string | undefined;
    sanPhamYeuThich?: string | undefined;
    maGiamGia?: string | undefined;
    nguoiTao?: string | undefined;
    rateStar?: number | undefined;

    constructor(data?: IKhoSpModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.khoId = _data["khoId"];
            this.tenSanPham = _data["tenSanPham"];
            this.maSp = _data["maSp"];
            this.soLuong = _data["soLuong"];
            this.shopId = _data["shopId"];
            this.productId = _data["productId"];
            this.canNang = _data["canNang"];
            this.dai = _data["dai"];
            this.rong = _data["rong"];
            this.cao = _data["cao"];
            this.image = _data["image"];
            this.listImage = _data["listImage"];
            this.colorId = _data["colorId"];
            this.sizeId = _data["sizeId"];
            this.giaSp = _data["giaSp"];
            this.giaCu = _data["giaCu"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.categoryId = _data["categoryId"];
            this.moTaSanPham = _data["moTaSanPham"];
            this.title = _data["title"];
            this.chiTietSanPham = _data["chiTietSanPham"];
            this.sanPhamYeuThich = _data["sanPhamYeuThich"];
            this.maGiamGia = _data["maGiamGia"];
            this.nguoiTao = _data["nguoiTao"];
            this.rateStar = _data["rateStar"];
        }
    }

    static fromJS(data: any, _mappings?: any): KhoSpModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KhoSpModel>(data, _mappings, KhoSpModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["khoId"] = this.khoId;
        data["tenSanPham"] = this.tenSanPham;
        data["maSp"] = this.maSp;
        data["soLuong"] = this.soLuong;
        data["shopId"] = this.shopId;
        data["productId"] = this.productId;
        data["canNang"] = this.canNang;
        data["dai"] = this.dai;
        data["rong"] = this.rong;
        data["cao"] = this.cao;
        data["image"] = this.image;
        data["listImage"] = this.listImage;
        data["colorId"] = this.colorId;
        data["sizeId"] = this.sizeId;
        data["giaSp"] = this.giaSp;
        data["giaCu"] = this.giaCu;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["categoryId"] = this.categoryId;
        data["moTaSanPham"] = this.moTaSanPham;
        data["title"] = this.title;
        data["chiTietSanPham"] = this.chiTietSanPham;
        data["sanPhamYeuThich"] = this.sanPhamYeuThich;
        data["maGiamGia"] = this.maGiamGia;
        data["nguoiTao"] = this.nguoiTao;
        data["rateStar"] = this.rateStar;
        return data;
    }
}

export interface IKhoSpModel {
    khoId?: string | undefined;
    tenSanPham?: string | undefined;
    maSp?: string | undefined;
    soLuong?: number | undefined;
    shopId?: string | undefined;
    productId?: string | undefined;
    canNang?: number | undefined;
    dai?: number | undefined;
    rong?: number | undefined;
    cao?: number | undefined;
    image?: string | undefined;
    listImage?: string | undefined;
    colorId?: string | undefined;
    sizeId?: string | undefined;
    giaSp?: number | undefined;
    giaCu?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    categoryId?: string | undefined;
    moTaSanPham?: string | undefined;
    title?: string | undefined;
    chiTietSanPham?: string | undefined;
    sanPhamYeuThich?: string | undefined;
    maGiamGia?: string | undefined;
    nguoiTao?: string | undefined;
    rateStar?: number | undefined;
}

export class KhoSpModelApiResponse implements IKhoSpModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: KhoSpModel;

    constructor(data?: IKhoSpModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new KhoSpModel(data.data) : <KhoSpModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? KhoSpModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): KhoSpModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KhoSpModelApiResponse>(data, _mappings, KhoSpModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKhoSpModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IKhoSpModel;
}

export class KhoSpModelListApiResponse implements IKhoSpModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: KhoSpModel[] | undefined;

    constructor(data?: IKhoSpModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new KhoSpModel(item) : <KhoSpModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(KhoSpModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): KhoSpModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KhoSpModelListApiResponse>(data, _mappings, KhoSpModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKhoSpModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IKhoSpModel[] | undefined;
}

export class KhoSpModelListPageModelView implements IKhoSpModelListPageModelView {
    data?: KhoSpModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IKhoSpModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new KhoSpModel(item) : <KhoSpModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(KhoSpModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): KhoSpModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KhoSpModelListPageModelView>(data, _mappings, KhoSpModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IKhoSpModelListPageModelView {
    data?: IKhoSpModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class KhoSpModelListPageModelViewApiResponse implements IKhoSpModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: KhoSpModelListPageModelView;

    constructor(data?: IKhoSpModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new KhoSpModelListPageModelView(data.data) : <KhoSpModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? KhoSpModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): KhoSpModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KhoSpModelListPageModelViewApiResponse>(data, _mappings, KhoSpModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKhoSpModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IKhoSpModelListPageModelView;
}

export class List_District implements IList_District {
    results?: List_DistrictData[] | undefined;

    constructor(data?: IList_District) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new List_DistrictData(item) : <List_DistrictData>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(List_DistrictData.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): List_District | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_District>(data, _mappings, List_District);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IList_District {
    results?: IList_DistrictData[] | undefined;
}

export class List_DistrictApiResponse implements IList_DistrictApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: List_District;

    constructor(data?: IList_DistrictApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new List_District(data.data) : <List_District>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? List_District.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): List_DistrictApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_DistrictApiResponse>(data, _mappings, List_DistrictApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IList_DistrictApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IList_District;
}

export class List_DistrictData implements IList_DistrictData {
    district_id?: string | undefined;
    district_name?: string | undefined;
    district_type?: string | undefined;
    lat?: any | undefined;
    lng?: any | undefined;
    province_id?: string | undefined;

    constructor(data?: IList_DistrictData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.district_id = _data["district_id"];
            this.district_name = _data["district_name"];
            this.district_type = _data["district_type"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.province_id = _data["province_id"];
        }
    }

    static fromJS(data: any, _mappings?: any): List_DistrictData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_DistrictData>(data, _mappings, List_DistrictData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["district_id"] = this.district_id;
        data["district_name"] = this.district_name;
        data["district_type"] = this.district_type;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["province_id"] = this.province_id;
        return data;
    }
}

export interface IList_DistrictData {
    district_id?: string | undefined;
    district_name?: string | undefined;
    district_type?: string | undefined;
    lat?: any | undefined;
    lng?: any | undefined;
    province_id?: string | undefined;
}

export class List_Province implements IList_Province {
    results?: List_ProvinceData[] | undefined;

    constructor(data?: IList_Province) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new List_ProvinceData(item) : <List_ProvinceData>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(List_ProvinceData.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): List_Province | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_Province>(data, _mappings, List_Province);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IList_Province {
    results?: IList_ProvinceData[] | undefined;
}

export class List_ProvinceApiResponse implements IList_ProvinceApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: List_Province;

    constructor(data?: IList_ProvinceApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new List_Province(data.data) : <List_Province>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? List_Province.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): List_ProvinceApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_ProvinceApiResponse>(data, _mappings, List_ProvinceApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IList_ProvinceApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IList_Province;
}

export class List_ProvinceData implements IList_ProvinceData {
    province_id?: string | undefined;
    province_name?: string | undefined;
    province_type?: string | undefined;

    constructor(data?: IList_ProvinceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.province_id = _data["province_id"];
            this.province_name = _data["province_name"];
            this.province_type = _data["province_type"];
        }
    }

    static fromJS(data: any, _mappings?: any): List_ProvinceData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_ProvinceData>(data, _mappings, List_ProvinceData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["province_id"] = this.province_id;
        data["province_name"] = this.province_name;
        data["province_type"] = this.province_type;
        return data;
    }
}

export interface IList_ProvinceData {
    province_id?: string | undefined;
    province_name?: string | undefined;
    province_type?: string | undefined;
}

export class List_Ward implements IList_Ward {
    results?: List_WardData[] | undefined;

    constructor(data?: IList_Ward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new List_WardData(item) : <List_WardData>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(List_WardData.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): List_Ward | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_Ward>(data, _mappings, List_Ward);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IList_Ward {
    results?: IList_WardData[] | undefined;
}

export class List_WardApiResponse implements IList_WardApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: List_Ward;

    constructor(data?: IList_WardApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new List_Ward(data.data) : <List_Ward>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? List_Ward.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): List_WardApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_WardApiResponse>(data, _mappings, List_WardApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IList_WardApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IList_Ward;
}

export class List_WardData implements IList_WardData {
    district_id?: string | undefined;
    ward_id?: string | undefined;
    ward_name?: string | undefined;
    ward_type?: string | undefined;

    constructor(data?: IList_WardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.district_id = _data["district_id"];
            this.ward_id = _data["ward_id"];
            this.ward_name = _data["ward_name"];
            this.ward_type = _data["ward_type"];
        }
    }

    static fromJS(data: any, _mappings?: any): List_WardData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<List_WardData>(data, _mappings, List_WardData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["district_id"] = this.district_id;
        data["ward_id"] = this.ward_id;
        data["ward_name"] = this.ward_name;
        data["ward_type"] = this.ward_type;
        return data;
    }
}

export interface IList_WardData {
    district_id?: string | undefined;
    ward_id?: string | undefined;
    ward_name?: string | undefined;
    ward_type?: string | undefined;
}

export class LoginUser implements ILoginUser {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginUser>(data, _mappings, LoginUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUser {
    userName?: string | undefined;
    password?: string | undefined;
}

export class PageModel implements IPageModel {
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
    search?: string | undefined;
    type?: string | undefined;
    trangThai?: number | undefined;
    typeFile?: number | undefined;

    constructor(data?: IPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
            this.search = _data["search"];
            this.type = _data["type"];
            this.trangThai = _data["trangThai"];
            this.typeFile = _data["typeFile"];
        }
    }

    static fromJS(data: any, _mappings?: any): PageModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PageModel>(data, _mappings, PageModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        data["search"] = this.search;
        data["type"] = this.type;
        data["trangThai"] = this.trangThai;
        data["typeFile"] = this.typeFile;
        return data;
    }
}

export interface IPageModel {
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
    search?: string | undefined;
    type?: string | undefined;
    trangThai?: number | undefined;
    typeFile?: number | undefined;
}

export class ProductModel implements IProductModel {
    productId?: string | undefined;
    tenSanPham?: string | undefined;
    moTaSanPham?: string | undefined;
    image?: string | undefined;
    giaSp?: number | undefined;
    soLuong?: number | undefined;
    giaCu?: number | undefined;
    dai?: number | undefined;
    rong?: number | undefined;
    cao?: number | undefined;
    maGiamGia?: string | undefined;
    categoryId?: string | undefined;
    sanPhamYeuThich?: string | undefined;
    chiTietMoTa?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    shopId?: string | undefined;
    shippingCardId?: string | undefined;
    nguoiTao?: string | undefined;
    rateStar?: number | undefined;
    khoId?: string | undefined;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.tenSanPham = _data["tenSanPham"];
            this.moTaSanPham = _data["moTaSanPham"];
            this.image = _data["image"];
            this.giaSp = _data["giaSp"];
            this.soLuong = _data["soLuong"];
            this.giaCu = _data["giaCu"];
            this.dai = _data["dai"];
            this.rong = _data["rong"];
            this.cao = _data["cao"];
            this.maGiamGia = _data["maGiamGia"];
            this.categoryId = _data["categoryId"];
            this.sanPhamYeuThich = _data["sanPhamYeuThich"];
            this.chiTietMoTa = _data["chiTietMoTa"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.shopId = _data["shopId"];
            this.shippingCardId = _data["shippingCardId"];
            this.nguoiTao = _data["nguoiTao"];
            this.rateStar = _data["rateStar"];
            this.khoId = _data["khoId"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProductModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProductModel>(data, _mappings, ProductModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["tenSanPham"] = this.tenSanPham;
        data["moTaSanPham"] = this.moTaSanPham;
        data["image"] = this.image;
        data["giaSp"] = this.giaSp;
        data["soLuong"] = this.soLuong;
        data["giaCu"] = this.giaCu;
        data["dai"] = this.dai;
        data["rong"] = this.rong;
        data["cao"] = this.cao;
        data["maGiamGia"] = this.maGiamGia;
        data["categoryId"] = this.categoryId;
        data["sanPhamYeuThich"] = this.sanPhamYeuThich;
        data["chiTietMoTa"] = this.chiTietMoTa;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["shopId"] = this.shopId;
        data["shippingCardId"] = this.shippingCardId;
        data["nguoiTao"] = this.nguoiTao;
        data["rateStar"] = this.rateStar;
        data["khoId"] = this.khoId;
        return data;
    }
}

export interface IProductModel {
    productId?: string | undefined;
    tenSanPham?: string | undefined;
    moTaSanPham?: string | undefined;
    image?: string | undefined;
    giaSp?: number | undefined;
    soLuong?: number | undefined;
    giaCu?: number | undefined;
    dai?: number | undefined;
    rong?: number | undefined;
    cao?: number | undefined;
    maGiamGia?: string | undefined;
    categoryId?: string | undefined;
    sanPhamYeuThich?: string | undefined;
    chiTietMoTa?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    shopId?: string | undefined;
    shippingCardId?: string | undefined;
    nguoiTao?: string | undefined;
    rateStar?: number | undefined;
    khoId?: string | undefined;
}

export class ProductModelApiResponse implements IProductModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ProductModel;

    constructor(data?: IProductModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ProductModel(data.data) : <ProductModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ProductModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProductModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProductModelApiResponse>(data, _mappings, ProductModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IProductModel;
}

export class ProductModelListApiResponse implements IProductModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ProductModel[] | undefined;

    constructor(data?: IProductModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ProductModel(item) : <ProductModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProductModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProductModelListApiResponse>(data, _mappings, ProductModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IProductModel[] | undefined;
}

export class ProductModelListPageModelView implements IProductModelListPageModelView {
    data?: ProductModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IProductModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ProductModel(item) : <ProductModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProductModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProductModelListPageModelView>(data, _mappings, ProductModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IProductModelListPageModelView {
    data?: IProductModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class ProductModelListPageModelViewApiResponse implements IProductModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ProductModelListPageModelView;

    constructor(data?: IProductModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ProductModelListPageModelView(data.data) : <ProductModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ProductModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ProductModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProductModelListPageModelViewApiResponse>(data, _mappings, ProductModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IProductModelListPageModelView;
}

export class ShippingCardModel implements IShippingCardModel {
    id?: string | undefined;
    tenSanPham?: string | undefined;
    moTaSanPham?: string | undefined;
    tieuDeSanPham?: string | undefined;
    phiVanChuyen?: number | undefined;
    tongTien?: number | undefined;
    maGiamGia?: string | undefined;
    maTrangThai?: string | undefined;
    tenTrangThai?: string | undefined;
    nhanDiaChi?: string | undefined;
    nhanXa?: string | undefined;
    nhanHuyen?: string | undefined;
    nhanTinh?: string | undefined;
    nhanTen?: string | undefined;
    guiDiaChi?: string | undefined;
    guiXa?: string | undefined;
    guiHuyen?: string | undefined;
    guiTinh?: string | undefined;
    guiTen?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    userId?: string | undefined;
    shopId?: string | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IShippingCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenSanPham = _data["tenSanPham"];
            this.moTaSanPham = _data["moTaSanPham"];
            this.tieuDeSanPham = _data["tieuDeSanPham"];
            this.phiVanChuyen = _data["phiVanChuyen"];
            this.tongTien = _data["tongTien"];
            this.maGiamGia = _data["maGiamGia"];
            this.maTrangThai = _data["maTrangThai"];
            this.tenTrangThai = _data["tenTrangThai"];
            this.nhanDiaChi = _data["nhanDiaChi"];
            this.nhanXa = _data["nhanXa"];
            this.nhanHuyen = _data["nhanHuyen"];
            this.nhanTinh = _data["nhanTinh"];
            this.nhanTen = _data["nhanTen"];
            this.guiDiaChi = _data["guiDiaChi"];
            this.guiXa = _data["guiXa"];
            this.guiHuyen = _data["guiHuyen"];
            this.guiTinh = _data["guiTinh"];
            this.guiTen = _data["guiTen"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.shopId = _data["shopId"];
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): ShippingCardModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShippingCardModel>(data, _mappings, ShippingCardModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenSanPham"] = this.tenSanPham;
        data["moTaSanPham"] = this.moTaSanPham;
        data["tieuDeSanPham"] = this.tieuDeSanPham;
        data["phiVanChuyen"] = this.phiVanChuyen;
        data["tongTien"] = this.tongTien;
        data["maGiamGia"] = this.maGiamGia;
        data["maTrangThai"] = this.maTrangThai;
        data["tenTrangThai"] = this.tenTrangThai;
        data["nhanDiaChi"] = this.nhanDiaChi;
        data["nhanXa"] = this.nhanXa;
        data["nhanHuyen"] = this.nhanHuyen;
        data["nhanTinh"] = this.nhanTinh;
        data["nhanTen"] = this.nhanTen;
        data["guiDiaChi"] = this.guiDiaChi;
        data["guiXa"] = this.guiXa;
        data["guiHuyen"] = this.guiHuyen;
        data["guiTinh"] = this.guiTinh;
        data["guiTen"] = this.guiTen;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["shopId"] = this.shopId;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IShippingCardModel {
    id?: string | undefined;
    tenSanPham?: string | undefined;
    moTaSanPham?: string | undefined;
    tieuDeSanPham?: string | undefined;
    phiVanChuyen?: number | undefined;
    tongTien?: number | undefined;
    maGiamGia?: string | undefined;
    maTrangThai?: string | undefined;
    tenTrangThai?: string | undefined;
    nhanDiaChi?: string | undefined;
    nhanXa?: string | undefined;
    nhanHuyen?: string | undefined;
    nhanTinh?: string | undefined;
    nhanTen?: string | undefined;
    guiDiaChi?: string | undefined;
    guiXa?: string | undefined;
    guiHuyen?: string | undefined;
    guiTinh?: string | undefined;
    guiTen?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    userId?: string | undefined;
    shopId?: string | undefined;
    nguoiTao?: string | undefined;
}

export class ShippingCardModelApiResponse implements IShippingCardModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShippingCardModel;

    constructor(data?: IShippingCardModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ShippingCardModel(data.data) : <ShippingCardModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ShippingCardModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ShippingCardModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShippingCardModelApiResponse>(data, _mappings, ShippingCardModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShippingCardModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShippingCardModel;
}

export class ShippingCardModelListApiResponse implements IShippingCardModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShippingCardModel[] | undefined;

    constructor(data?: IShippingCardModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ShippingCardModel(item) : <ShippingCardModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShippingCardModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ShippingCardModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShippingCardModelListApiResponse>(data, _mappings, ShippingCardModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShippingCardModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShippingCardModel[] | undefined;
}

export class ShippingCardModelListPageModelView implements IShippingCardModelListPageModelView {
    data?: ShippingCardModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IShippingCardModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ShippingCardModel(item) : <ShippingCardModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShippingCardModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): ShippingCardModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShippingCardModelListPageModelView>(data, _mappings, ShippingCardModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IShippingCardModelListPageModelView {
    data?: IShippingCardModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class ShippingCardModelListPageModelViewApiResponse implements IShippingCardModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShippingCardModelListPageModelView;

    constructor(data?: IShippingCardModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ShippingCardModelListPageModelView(data.data) : <ShippingCardModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ShippingCardModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ShippingCardModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShippingCardModelListPageModelViewApiResponse>(data, _mappings, ShippingCardModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShippingCardModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShippingCardModelListPageModelView;
}

export class ShopUserModel implements IShopUserModel {
    shopId?: string | undefined;
    nameShop?: string | undefined;
    mota?: string | undefined;
    diaChi?: string | undefined;
    maXa?: string | undefined;
    maHuyen?: string | undefined;
    maTinh?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    userId?: string | undefined;
    maCha?: string | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IShopUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.shopId = _data["shopId"];
            this.nameShop = _data["nameShop"];
            this.mota = _data["mota"];
            this.diaChi = _data["diaChi"];
            this.maXa = _data["maXa"];
            this.maHuyen = _data["maHuyen"];
            this.maTinh = _data["maTinh"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.maCha = _data["maCha"];
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): ShopUserModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShopUserModel>(data, _mappings, ShopUserModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shopId"] = this.shopId;
        data["nameShop"] = this.nameShop;
        data["mota"] = this.mota;
        data["diaChi"] = this.diaChi;
        data["maXa"] = this.maXa;
        data["maHuyen"] = this.maHuyen;
        data["maTinh"] = this.maTinh;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["maCha"] = this.maCha;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IShopUserModel {
    shopId?: string | undefined;
    nameShop?: string | undefined;
    mota?: string | undefined;
    diaChi?: string | undefined;
    maXa?: string | undefined;
    maHuyen?: string | undefined;
    maTinh?: string | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    status?: number | undefined;
    userId?: string | undefined;
    maCha?: string | undefined;
    nguoiTao?: string | undefined;
}

export class ShopUserModelApiResponse implements IShopUserModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShopUserModel;

    constructor(data?: IShopUserModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ShopUserModel(data.data) : <ShopUserModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ShopUserModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ShopUserModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShopUserModelApiResponse>(data, _mappings, ShopUserModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShopUserModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShopUserModel;
}

export class ShopUserModelListApiResponse implements IShopUserModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShopUserModel[] | undefined;

    constructor(data?: IShopUserModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ShopUserModel(item) : <ShopUserModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShopUserModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ShopUserModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShopUserModelListApiResponse>(data, _mappings, ShopUserModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShopUserModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShopUserModel[] | undefined;
}

export class ShopUserModelListPageModelView implements IShopUserModelListPageModelView {
    data?: ShopUserModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IShopUserModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ShopUserModel(item) : <ShopUserModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShopUserModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): ShopUserModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShopUserModelListPageModelView>(data, _mappings, ShopUserModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IShopUserModelListPageModelView {
    data?: IShopUserModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class ShopUserModelListPageModelViewApiResponse implements IShopUserModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ShopUserModelListPageModelView;

    constructor(data?: IShopUserModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ShopUserModelListPageModelView(data.data) : <ShopUserModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? ShopUserModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ShopUserModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ShopUserModelListPageModelViewApiResponse>(data, _mappings, ShopUserModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShopUserModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IShopUserModelListPageModelView;
}

export class SliderModel implements ISliderModel {
    sliderId?: string | undefined;
    image?: string | undefined;
    title?: string | undefined;
    mota?: string | undefined;
    status?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: ISliderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.sliderId = _data["sliderId"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.mota = _data["mota"];
            this.status = _data["status"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): SliderModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SliderModel>(data, _mappings, SliderModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sliderId"] = this.sliderId;
        data["image"] = this.image;
        data["title"] = this.title;
        data["mota"] = this.mota;
        data["status"] = this.status;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface ISliderModel {
    sliderId?: string | undefined;
    image?: string | undefined;
    title?: string | undefined;
    mota?: string | undefined;
    status?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;
}

export class SliderModelApiResponse implements ISliderModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SliderModel;

    constructor(data?: ISliderModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SliderModel(data.data) : <SliderModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SliderModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SliderModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SliderModelApiResponse>(data, _mappings, SliderModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISliderModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISliderModel;
}

export class SliderModelListApiResponse implements ISliderModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SliderModel[] | undefined;

    constructor(data?: ISliderModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SliderModel(item) : <SliderModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SliderModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SliderModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SliderModelListApiResponse>(data, _mappings, SliderModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISliderModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISliderModel[] | undefined;
}

export class SliderModelListPageModelView implements ISliderModelListPageModelView {
    data?: SliderModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ISliderModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SliderModel(item) : <SliderModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SliderModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): SliderModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SliderModelListPageModelView>(data, _mappings, SliderModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ISliderModelListPageModelView {
    data?: ISliderModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class SliderModelListPageModelViewApiResponse implements ISliderModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SliderModelListPageModelView;

    constructor(data?: ISliderModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SliderModelListPageModelView(data.data) : <SliderModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SliderModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SliderModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SliderModelListPageModelViewApiResponse>(data, _mappings, SliderModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISliderModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISliderModelListPageModelView;
}

export class StringApiResponse implements IStringApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any, _mappings?: any): StringApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StringApiResponse>(data, _mappings, StringApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IStringApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
}

export class StringListApiResponse implements IStringListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: string[] | undefined;

    constructor(data?: IStringListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): StringListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StringListApiResponse>(data, _mappings, StringListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

export interface IStringListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: string[] | undefined;
}

export class SysGroupMenuModel implements ISysGroupMenuModel {
    groupId?: string | undefined;
    tenNhomMenu?: string | undefined;
    tenMenu?: string | undefined;
    menuId?: string | undefined;
    function?: string | undefined;

    constructor(data?: ISysGroupMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.tenNhomMenu = _data["tenNhomMenu"];
            this.tenMenu = _data["tenMenu"];
            this.menuId = _data["menuId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupMenuModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupMenuModel>(data, _mappings, SysGroupMenuModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["tenNhomMenu"] = this.tenNhomMenu;
        data["tenMenu"] = this.tenMenu;
        data["menuId"] = this.menuId;
        data["function"] = this.function;
        return data;
    }
}

export interface ISysGroupMenuModel {
    groupId?: string | undefined;
    tenNhomMenu?: string | undefined;
    tenMenu?: string | undefined;
    menuId?: string | undefined;
    function?: string | undefined;
}

export class SysGroupMenuModelApiResponse implements ISysGroupMenuModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupMenuModel;

    constructor(data?: ISysGroupMenuModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysGroupMenuModel(data.data) : <SysGroupMenuModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysGroupMenuModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupMenuModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupMenuModelApiResponse>(data, _mappings, SysGroupMenuModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysGroupMenuModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupMenuModel;
}

export class SysGroupMenuModelListApiResponse implements ISysGroupMenuModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupMenuModel[] | undefined;

    constructor(data?: ISysGroupMenuModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysGroupMenuModel(item) : <SysGroupMenuModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGroupMenuModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupMenuModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupMenuModelListApiResponse>(data, _mappings, SysGroupMenuModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysGroupMenuModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupMenuModel[] | undefined;
}

export class SysGroupMenuModelListPageModelView implements ISysGroupMenuModelListPageModelView {
    data?: SysGroupMenuModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ISysGroupMenuModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysGroupMenuModel(item) : <SysGroupMenuModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGroupMenuModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupMenuModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupMenuModelListPageModelView>(data, _mappings, SysGroupMenuModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ISysGroupMenuModelListPageModelView {
    data?: ISysGroupMenuModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class SysGroupMenuModelListPageModelViewApiResponse implements ISysGroupMenuModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupMenuModelListPageModelView;

    constructor(data?: ISysGroupMenuModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysGroupMenuModelListPageModelView(data.data) : <SysGroupMenuModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysGroupMenuModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupMenuModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupMenuModelListPageModelViewApiResponse>(data, _mappings, SysGroupMenuModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysGroupMenuModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupMenuModelListPageModelView;
}

export class SysGroupModel implements ISysGroupModel {
    groupId?: string | undefined;
    groupName?: string | undefined;
    status?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: ISysGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.status = _data["status"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupModel>(data, _mappings, SysGroupModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["status"] = this.status;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface ISysGroupModel {
    groupId?: string | undefined;
    groupName?: string | undefined;
    status?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;
}

export class SysGroupModelApiResponse implements ISysGroupModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupModel;

    constructor(data?: ISysGroupModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysGroupModel(data.data) : <SysGroupModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysGroupModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupModelApiResponse>(data, _mappings, SysGroupModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysGroupModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupModel;
}

export class SysGroupModelListApiResponse implements ISysGroupModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupModel[] | undefined;

    constructor(data?: ISysGroupModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysGroupModel(item) : <SysGroupModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGroupModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupModelListApiResponse>(data, _mappings, SysGroupModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysGroupModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupModel[] | undefined;
}

export class SysGroupModelListPageModelView implements ISysGroupModelListPageModelView {
    data?: SysGroupModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ISysGroupModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysGroupModel(item) : <SysGroupModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGroupModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupModelListPageModelView>(data, _mappings, SysGroupModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ISysGroupModelListPageModelView {
    data?: ISysGroupModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class SysGroupModelListPageModelViewApiResponse implements ISysGroupModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysGroupModelListPageModelView;

    constructor(data?: ISysGroupModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysGroupModelListPageModelView(data.data) : <SysGroupModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysGroupModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysGroupModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysGroupModelListPageModelViewApiResponse>(data, _mappings, SysGroupModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysGroupModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysGroupModelListPageModelView;
}

export class SysMenuModel implements ISysMenuModel {
    menuId?: string | undefined;
    maChucNang?: string | undefined;
    maCha?: string | undefined;
    tenChucNang?: string | undefined;
    state?: string | undefined;
    icon?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: ISysMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.menuId = _data["menuId"];
            this.maChucNang = _data["maChucNang"];
            this.maCha = _data["maCha"];
            this.tenChucNang = _data["tenChucNang"];
            this.state = _data["state"];
            this.icon = _data["icon"];
            this.trangThai = _data["trangThai"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysMenuModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysMenuModel>(data, _mappings, SysMenuModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["maChucNang"] = this.maChucNang;
        data["maCha"] = this.maCha;
        data["tenChucNang"] = this.tenChucNang;
        data["state"] = this.state;
        data["icon"] = this.icon;
        data["trangThai"] = this.trangThai;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface ISysMenuModel {
    menuId?: string | undefined;
    maChucNang?: string | undefined;
    maCha?: string | undefined;
    tenChucNang?: string | undefined;
    state?: string | undefined;
    icon?: string | undefined;
    trangThai?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;
}

export class SysMenuModelApiResponse implements ISysMenuModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysMenuModel;

    constructor(data?: ISysMenuModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysMenuModel(data.data) : <SysMenuModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysMenuModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysMenuModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysMenuModelApiResponse>(data, _mappings, SysMenuModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysMenuModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysMenuModel;
}

export class SysMenuModelListApiResponse implements ISysMenuModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysMenuModel[] | undefined;

    constructor(data?: ISysMenuModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysMenuModel(item) : <SysMenuModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysMenuModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SysMenuModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysMenuModelListApiResponse>(data, _mappings, SysMenuModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysMenuModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysMenuModel[] | undefined;
}

export class SysMenuModelListPageModelView implements ISysMenuModelListPageModelView {
    data?: SysMenuModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ISysMenuModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysMenuModel(item) : <SysMenuModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysMenuModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysMenuModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysMenuModelListPageModelView>(data, _mappings, SysMenuModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ISysMenuModelListPageModelView {
    data?: ISysMenuModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class SysMenuModelListPageModelViewApiResponse implements ISysMenuModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysMenuModelListPageModelView;

    constructor(data?: ISysMenuModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysMenuModelListPageModelView(data.data) : <SysMenuModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysMenuModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysMenuModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysMenuModelListPageModelViewApiResponse>(data, _mappings, SysMenuModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysMenuModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysMenuModelListPageModelView;
}

export class SysUserModel implements ISysUserModel {
    userId?: string | undefined;
    userName?: string | undefined;
    passWord?: string | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    maTinh?: string | undefined;
    maHuyen?: string | undefined;
    maXa?: string | undefined;
    typeUser?: string | undefined;
    gender?: number | undefined;
    active?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
    tokenData?: string | undefined;

    constructor(data?: ISysUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.passWord = _data["passWord"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.maTinh = _data["maTinh"];
            this.maHuyen = _data["maHuyen"];
            this.maXa = _data["maXa"];
            this.typeUser = _data["typeUser"];
            this.gender = _data["gender"];
            this.active = _data["active"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.nguoiTao = _data["nguoiTao"];
            this.tokenData = _data["tokenData"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysUserModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysUserModel>(data, _mappings, SysUserModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["passWord"] = this.passWord;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["address"] = this.address;
        data["maTinh"] = this.maTinh;
        data["maHuyen"] = this.maHuyen;
        data["maXa"] = this.maXa;
        data["typeUser"] = this.typeUser;
        data["gender"] = this.gender;
        data["active"] = this.active;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["nguoiTao"] = this.nguoiTao;
        data["tokenData"] = this.tokenData;
        return data;
    }
}

export interface ISysUserModel {
    userId?: string | undefined;
    userName?: string | undefined;
    passWord?: string | undefined;
    fullName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    maTinh?: string | undefined;
    maHuyen?: string | undefined;
    maXa?: string | undefined;
    typeUser?: string | undefined;
    gender?: number | undefined;
    active?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    trangThai?: number | undefined;
    nguoiTao?: string | undefined;
    tokenData?: string | undefined;
}

export class SysUserModelApiResponse implements ISysUserModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysUserModel;

    constructor(data?: ISysUserModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysUserModel(data.data) : <SysUserModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysUserModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysUserModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysUserModelApiResponse>(data, _mappings, SysUserModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysUserModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysUserModel;
}

export class SysUserModelListApiResponse implements ISysUserModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysUserModel[] | undefined;

    constructor(data?: ISysUserModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysUserModel(item) : <SysUserModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysUserModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SysUserModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysUserModelListApiResponse>(data, _mappings, SysUserModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysUserModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysUserModel[] | undefined;
}

export class SysUserModelListPageModelView implements ISysUserModelListPageModelView {
    data?: SysUserModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: ISysUserModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new SysUserModel(item) : <SysUserModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysUserModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): SysUserModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysUserModelListPageModelView>(data, _mappings, SysUserModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface ISysUserModelListPageModelView {
    data?: ISysUserModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class SysUserModelListPageModelViewApiResponse implements ISysUserModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: SysUserModelListPageModelView;

    constructor(data?: ISysUserModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new SysUserModelListPageModelView(data.data) : <SysUserModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? SysUserModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SysUserModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SysUserModelListPageModelViewApiResponse>(data, _mappings, SysUserModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISysUserModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: ISysUserModelListPageModelView;
}

export class VoucherModel implements IVoucherModel {
    voucherId?: string | undefined;
    nameVoucher?: string | undefined;
    mota?: string | undefined;
    giamPhanTram?: number | undefined;
    giamTien?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    trangThai?: number | undefined;
    soLuong?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;

    constructor(data?: IVoucherModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.voucherId = _data["voucherId"];
            this.nameVoucher = _data["nameVoucher"];
            this.mota = _data["mota"];
            this.giamPhanTram = _data["giamPhanTram"];
            this.giamTien = _data["giamTien"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trangThai = _data["trangThai"];
            this.soLuong = _data["soLuong"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherModel>(data, _mappings, VoucherModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["voucherId"] = this.voucherId;
        data["nameVoucher"] = this.nameVoucher;
        data["mota"] = this.mota;
        data["giamPhanTram"] = this.giamPhanTram;
        data["giamTien"] = this.giamTien;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trangThai"] = this.trangThai;
        data["soLuong"] = this.soLuong;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data;
    }
}

export interface IVoucherModel {
    voucherId?: string | undefined;
    nameVoucher?: string | undefined;
    mota?: string | undefined;
    giamPhanTram?: number | undefined;
    giamTien?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    trangThai?: number | undefined;
    soLuong?: number | undefined;
    createDate?: Date | undefined;
    updateDate?: Date | undefined;
    nguoiTao?: string | undefined;
}

export class VoucherModelApiResponse implements IVoucherModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: VoucherModel;

    constructor(data?: IVoucherModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new VoucherModel(data.data) : <VoucherModel>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? VoucherModel.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherModelApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherModelApiResponse>(data, _mappings, VoucherModelApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVoucherModelApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IVoucherModel;
}

export class VoucherModelListApiResponse implements IVoucherModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: VoucherModel[] | undefined;

    constructor(data?: IVoucherModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VoucherModel(item) : <VoucherModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VoucherModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherModelListApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherModelListApiResponse>(data, _mappings, VoucherModelListApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVoucherModelListApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IVoucherModel[] | undefined;
}

export class VoucherModelListPageModelView implements IVoucherModelListPageModelView {
    data?: VoucherModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;

    constructor(data?: IVoucherModelListPageModelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new VoucherModel(item) : <VoucherModel>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VoucherModel.fromJS(item, _mappings));
            }
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            this.totalRecode = _data["totalRecode"];
            this.totalPage = _data["totalPage"];
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherModelListPageModelView | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherModelListPageModelView>(data, _mappings, VoucherModelListPageModelView);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalRecode"] = this.totalRecode;
        data["totalPage"] = this.totalPage;
        return data;
    }
}

export interface IVoucherModelListPageModelView {
    data?: IVoucherModel[] | undefined;
    pageSize?: number;
    currentPage?: number;
    totalRecode?: number;
    totalPage?: number;
}

export class VoucherModelListPageModelViewApiResponse implements IVoucherModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: VoucherModelListPageModelView;

    constructor(data?: IVoucherModelListPageModelViewApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new VoucherModelListPageModelView(data.data) : <VoucherModelListPageModelView>this.data;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"] ? VoucherModelListPageModelView.fromJS(_data["data"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherModelListPageModelViewApiResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherModelListPageModelViewApiResponse>(data, _mappings, VoucherModelListPageModelViewApiResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVoucherModelListPageModelViewApiResponse {
    code?: string | undefined;
    message?: string | undefined;
    data?: IVoucherModelListPageModelView;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}